#include <protoPython/CppGenerator.h>
#include <algorithm>

namespace protoPython {

bool CppGenerator::generate(ModuleNode* module, const std::string& filename) {
    header_.str("");
    header_.clear();
    body_.str("");
    body_.clear();

    // 1. Module Initialization setup
    out_ = &body_;
    *out_ << "extern \"C\" void* proto_module_init() {\n";
    *out_ << "    auto* ctx = protoPython::PythonEnvironment::getCurrentContext();\n";
    *out_ << "    auto* env = protoPython::PythonEnvironment::get(ctx);\n";
    *out_ << "    if (std::getenv(\"PROTO_ENV_DIAG\")) {\n";
    *out_ << "        fprintf(stderr, \"[mod] proto_module_init ctx=%p\\n\", (void*)ctx);\n";
    *out_ << "        const proto::ProtoObject* p = env->lookupName(\"print\");\n";
    *out_ << "        fprintf(stderr, \"[mod] lookupName('print')=%p\\n\", (void*)p);\n";
    *out_ << "        fflush(stderr);\n";
    *out_ << "    }\n\n";

    for (auto& stmt : module->body) {
        if (stmt->line > 0) emitLineDirective(stmt->line, filename);
        if (!generateNode(stmt.get())) return false;
        *out_ << ";\n";
    }
    
    *out_ << "    return nullptr;\n";
    *out_ << "}\n";

    // 2. Final assembly
    finalOut_ << "// Generated by protopyc from " << filename << "\n";
    finalOut_ << "#include <thread>\n";
    finalOut_ << "#include <protoCore.h>\n";
    finalOut_ << "#include <protoPython/PythonEnvironment.h>\n";
    finalOut_ << "#include <protoPython/Tokenizer.h>\n";
    finalOut_ << "#include <algorithm>\n\n";
    
    finalOut_ << header_.str();
    finalOut_ << body_.str();
    
    return true;
}

void CppGenerator::emitLineDirective(int line, const std::string& filename) {
    *out_ << "#line " << line << " \"" << filename << "\"\n";
}

bool CppGenerator::generateNode(ASTNode* node) {
    if (auto* n = dynamic_cast<ConstantNode*>(node)) {
        return generateConstant(n);
    } else if (auto* n = dynamic_cast<NameNode*>(node)) {
        return generateName(n);
    } else if (auto* n = dynamic_cast<CallNode*>(node)) {
        return generateCall(n);
    } else if (auto* n = dynamic_cast<SuiteNode*>(node)) {
        for (auto& stmt : n->statements) {
            if (stmt->line > 0) emitLineDirective(stmt->line, "source.py"); // TODO
            if (!generateNode(stmt.get())) return false;
            *out_ << ";\n";
        }
        return true;
    } else if (auto* n = dynamic_cast<AssignNode*>(node)) {
        return generateAssign(n);
    } else if (auto* n = dynamic_cast<IfNode*>(node)) {
        return generateIf(n);
    } else if (auto* n = dynamic_cast<BinOpNode*>(node)) {
        return generateBinOp(n);
    } else if (auto* n = dynamic_cast<PassNode*>(node)) {
        return generatePass(n);
    } else if (auto* n = dynamic_cast<BreakNode*>(node)) {
        return generateBreak(n);
    } else if (auto* n = dynamic_cast<ContinueNode*>(node)) {
        return generateContinue(n);
    } else if (auto* n = dynamic_cast<FunctionDefNode*>(node)) {
        return generateFunctionDef(n);
    } else if (auto* n = dynamic_cast<ReturnNode*>(node)) {
        return generateReturn(n);
    } else if (auto* n = dynamic_cast<AttributeNode*>(node)) {
        return generateAttribute(n);
    } else if (auto* n = dynamic_cast<SubscriptNode*>(node)) {
        return generateSubscript(n);
    } else if (auto* n = dynamic_cast<ListLiteralNode*>(node)) {
        return generateListLiteral(n);
    } else if (auto* n = dynamic_cast<DictLiteralNode*>(node)) {
        return generateDictLiteral(n);
    } else if (auto* n = dynamic_cast<TupleLiteralNode*>(node)) {
        return generateTupleLiteral(n);
    } else if (auto* n = dynamic_cast<WhileNode*>(node)) {
        return generateWhile(n);
    } else if (auto* n = dynamic_cast<UnaryOpNode*>(node)) {
        return generateUnaryOp(n);
    } else if (auto* n = dynamic_cast<AugAssignNode*>(node)) {
        return generateAugAssign(n);
    } else if (auto* n = dynamic_cast<ForNode*>(node)) {
        return generateFor(n);
    } else if (auto* n = dynamic_cast<TryNode*>(node)) {
        return generateTry(n);
    } else if (auto* n = dynamic_cast<RaiseNode*>(node)) {
        return generateRaise(n);
    } else if (auto* n = dynamic_cast<WithNode*>(node)) {
        return generateWith(n);
    } else if (auto* n = dynamic_cast<ImportNode*>(node)) {
        return generateImport(n);
    } else if (auto* n = dynamic_cast<ImportFromNode*>(node)) {
        return generateImportFrom(n);
    } else if (auto* n = dynamic_cast<ClassDefNode*>(node)) {
        return generateClassDef(n);
    } else if (auto* n = dynamic_cast<LambdaNode*>(node)) {
        return generateLambda(n);
    } else if (auto* n = dynamic_cast<JoinedStrNode*>(node)) {
        return generateJoinedStr(n);
    } else if (auto* n = dynamic_cast<FormattedValueNode*>(node)) {
        return generateFormattedValue(n);
    } else if (auto* n = dynamic_cast<SliceNode*>(node)) {
        return generateSlice(n);
    } else if (auto* n = dynamic_cast<DeleteNode*>(node)) {
        return generateDeleteNode(n);
    } else if (auto* n = dynamic_cast<AsyncFunctionDefNode*>(node)) {
        return generateAsyncFunctionDef(n);
    } else if (auto* n = dynamic_cast<AssertNode*>(node)) {
        return generateAssert(n);
    } else if (auto* n = dynamic_cast<YieldNode*>(node)) {
        return generateYield(n);
    } else if (auto* n = dynamic_cast<AwaitNode*>(node)) {
        return generateAwait(n);
    } else if (auto* n = dynamic_cast<StarredNode*>(node)) {
        return generateStarred(n);
    } else if (auto* n = dynamic_cast<AnnAssignNode*>(node)) {
        return generateAnnAssign(n);
    } else if (auto* n = dynamic_cast<NamedExprNode*>(node)) {
        return generateNamedExpr(n);
    } else if (auto* n = dynamic_cast<SetLiteralNode*>(node)) {
        return generateSetLiteral(n);
    }
    
    *out_ << "/* Unsupported node: " << typeid(*node).name() << " */";
    return true; 
}

bool CppGenerator::generateConstant(ConstantNode* n) {
    switch (n->constType) {
        case ConstantNode::ConstType::Int:
            *out_ << "ctx->fromInteger(" << n->intVal << ")";
            break;
        case ConstantNode::ConstType::Float:
            *out_ << "ctx->fromDouble(" << n->floatVal << ")";
            break;
        case ConstantNode::ConstType::Str:
            *out_ << "ctx->fromUTF8String(\"" << n->strVal << "\")";
            break;
        case ConstantNode::ConstType::Bool:
            *out_ << (n->intVal ? "PROTO_TRUE" : "PROTO_FALSE");
            break;
        case ConstantNode::ConstType::None:
            *out_ << "PROTO_NONE";
            break;
    }
    return true;
}

bool CppGenerator::generateName(NameNode* n) {
    if (inStateMachine_) {
        // Check if it's a local variable
        auto it = std::find(orderedLocalVars_.begin(), orderedLocalVars_.end(), n->id);
        if (it != orderedLocalVars_.end()) {
            *out_ << "local_" << n->id;
            return true;
        }
    }
    *out_ << "env->lookupName(\"" << n->id << "\")";
    return true;
}

bool CppGenerator::generateCall(CallNode* n) {
    bool hasUnpacking = false;
    for (auto& a : n->args) if (dynamic_cast<StarredNode*>(a.get())) { hasUnpacking = true; break; }
    if (!hasUnpacking) {
        for (auto& kw : n->keywords) if (kw.first.empty()) { hasUnpacking = true; break; }
    }

    if (!hasUnpacking) {
        if (n->keywords.empty()) {
            *out_ << "env->callObject(";
            if (!generateNode(n->func.get())) return false;
            *out_ << ", {";
            for (size_t i = 0; i < n->args.size(); ++i) {
                if (i > 0) *out_ << ", ";
                if (!generateNode(n->args[i].get())) return false;
            }
            *out_ << "})";
        } else {
            *out_ << "env->callObjectEx(";
            if (!generateNode(n->func.get())) return false;
            *out_ << ", {";
            for (size_t i = 0; i < n->args.size(); ++i) {
                if (i > 0) *out_ << ", ";
                if (!generateNode(n->args[i].get())) return false;
            }
            *out_ << "}, {";
            for (size_t i = 0; i < n->keywords.size(); ++i) {
                if (i > 0) *out_ << ", ";
                *out_ << "{\"" << n->keywords[i].first << "\", ";
                if (!generateNode(n->keywords[i].second.get())) return false;
                *out_ << "}";
            }
            *out_ << "})";
        }
    } else {
        // PEP 448 multiple unpacking. 
        // Build them using helpers or blocks.
        *out_ << "([&]() {\n";
        *out_ << "        auto* __f = "; if (!generateNode(n->func.get())) return false; *out_ << ";\n";
        *out_ << "        auto* __alst = ctx->newList();\n";
        for (auto& a : n->args) {
            if (auto* s = dynamic_cast<StarredNode*>(a.get())) {
                *out_ << "        __alst = ctx->listExtend(ctx, __alst, (const proto::ProtoList*)env->getAttr("; 
                if (!generateNode(s->value.get())) return false;
                *out_ << ", env->getDataString()));\n";
            } else {
                *out_ << "        __alst = __alst->appendLast(ctx, ";
                if (!generateNode(a.get())) return false;
                *out_ << ");\n";
            }
        }
        *out_ << "        bool __hasKw = false;\n";
        *out_ << "        auto* __kmap = ctx->newSparseList();\n";
        for (auto& kw : n->keywords) {
            *out_ << "        __hasKw = true;\n";
            if (kw.first.empty()) {
                *out_ << "        __kmap = ctx->dictUpdate(ctx, __kmap, (const proto::ProtoSparseList*)env->getAttr(";
                if (!generateNode(kw.second.get())) return false;
                *out_ << ", env->getDataString()));\n";
            } else {
                *out_ << "        __kmap = __kmap->setAt(ctx, ctx->fromUTF8String(\"" << kw.first << "\")->getHash(ctx), ";
                if (!generateNode(kw.second.get())) return false;
                *out_ << ");\n";
            }
        }
        *out_ << "        return env->callObjectEx(__f, {}, {}, ctx->newTupleFromList(__alst)->asObject(ctx), __hasKw ? __kmap->asObject(ctx) : nullptr);\n";
        *out_ << "    })()";
    }
    return true;
}

bool CppGenerator::generateStarred(StarredNode* n) {
    return generateNode(n->value.get());
}

bool CppGenerator::generateAnnAssign(AnnAssignNode* n) {
    if (n->value) {
        std::ostringstream valStream;
        std::ostream* oldOut = out_;
        out_ = &valStream;
        if (!generateNode(n->value.get())) return false;
        out_ = oldOut;
        return generateAssignToTarget(n->target.get(), valStream.str());
    }
    return true;
}

bool CppGenerator::generateAssignToTarget(ASTNode* target, const std::string& valueExpr) {
    if (auto* nameNode = dynamic_cast<NameNode*>(target)) {
        if (inStateMachine_) {
            auto it = std::find(orderedLocalVars_.begin(), orderedLocalVars_.end(), nameNode->id);
            if (it != orderedLocalVars_.end()) {
                *out_ << "local_" << nameNode->id << " = " << valueExpr;
                return true;
            }
        }
        *out_ << "env->storeName(\"" << nameNode->id << "\", " << valueExpr << ")";
        return true;
    } else if (auto* attrNode = dynamic_cast<AttributeNode*>(target)) {
        *out_ << "env->setAttr(";
        if (!generateNode(attrNode->value.get())) return false;
        *out_ << ", \"" << attrNode->attr << "\", " << valueExpr << ")";
        return true;
    } else if (auto* subNode = dynamic_cast<SubscriptNode*>(target)) {
        *out_ << "env->setItem(";
        if (!generateNode(subNode->value.get())) return false;
        *out_ << ", ";
        if (!generateNode(subNode->index.get())) return false;
        *out_ << ", " << valueExpr << ")";
        return true;
    }
    *out_ << "/* Unsupported assignment target */";
    return true;
}

bool CppGenerator::generateAssign(AssignNode* n) {
    if (n->targets.empty()) return true;

    if (n->targets.size() == 1) {
        std::ostringstream valStream;
        std::ostream* oldOut = out_;
        out_ = &valStream;
        if (!generateNode(n->value.get())) return false;
        out_ = oldOut;
        return generateAssignToTarget(n->targets[0].get(), valStream.str());
    } else {
        *out_ << "{\n";
        *out_ << "const proto::ProtoObject* _gen_tmp = ";
        if (!generateNode(n->value.get())) return false;
        *out_ << ";\n";
        for (auto& t : n->targets) {
            if (!generateAssignToTarget(t.get(), "_gen_tmp")) return false;
            *out_ << ";\n";
        }
        *out_ << "}\n";
        return true;
    }
}

bool CppGenerator::generateIf(IfNode* n) {
    *out_ << "if (env->isTrue(";
    if (!generateNode(n->test.get())) return false;
    *out_ << ")) {\n";
    if (!generateNode(n->body.get())) return false;
    *out_ << ";\n}";
    if (n->orelse) {
        *out_ << " else {\n";
        if (!generateNode(n->orelse.get())) return false;
        *out_ << ";\n}";
    }
    return true;
}

bool CppGenerator::generateWhile(WhileNode* n) {
    if (n->orelse) {
        *out_ << "while (true) {\n";
        *out_ << "    if (!env->isTrue(";
        if (!generateNode(n->test.get())) return false;
        *out_ << ")) {\n";
        if (!generateNode(n->orelse.get())) return false;
        *out_ << ";\n";
        *out_ << "        break;\n";
        *out_ << "    }\n";
        if (!generateNode(n->body.get())) return false;
        *out_ << ";\n}\n";
    } else {
        *out_ << "while (env->isTrue(";
        if (!generateNode(n->test.get())) return false;
        *out_ << ")) {\n";
        if (!generateNode(n->body.get())) return false;
        *out_ << ";\n}\n";
    }
    return true;
}

bool CppGenerator::generateUnaryOp(UnaryOpNode* n) {
    *out_ << "env->unaryOp(";
    switch (n->op) {
        case TokenType::Plus: *out_ << "protoPython::TokenType::Plus"; break;
        case TokenType::Minus: *out_ << "protoPython::TokenType::Minus"; break;
        case TokenType::Not: *out_ << "protoPython::TokenType::Not"; break;
        case TokenType::Tilde: *out_ << "protoPython::TokenType::Tilde"; break;
        default: *out_ << "protoPython::TokenType::Plus /* Unsupported uop */"; break;
    }
    *out_ << ", ";
    if (!generateNode(n->operand.get())) return false;
    *out_ << ")";
    return true;
}

bool CppGenerator::generateBinOp(BinOpNode* n) {
    *out_ << "env->binaryOp(";
    if (!generateNode(n->left.get())) return false;
    *out_ << ", ";
    switch (n->op) {
        case TokenType::Plus: *out_ << "protoPython::TokenType::Plus"; break;
        case TokenType::Minus: *out_ << "protoPython::TokenType::Minus"; break;
        case TokenType::Star: *out_ << "protoPython::TokenType::Star"; break;
        case TokenType::Slash: *out_ << "protoPython::TokenType::Slash"; break;
        case TokenType::Modulo: *out_ << "protoPython::TokenType::Modulo"; break;
        case TokenType::EqEqual: *out_ << "protoPython::TokenType::EqEqual"; break;
        case TokenType::NotEqual: *out_ << "protoPython::TokenType::NotEqual"; break;
        case TokenType::Less: *out_ << "protoPython::TokenType::Less"; break;
        case TokenType::LessEqual: *out_ << "protoPython::TokenType::LessEqual"; break;
        case TokenType::Greater: *out_ << "protoPython::TokenType::Greater"; break;
        case TokenType::GreaterEqual: *out_ << "protoPython::TokenType::GreaterEqual"; break;
        case TokenType::BitAnd: *out_ << "protoPython::TokenType::BitAnd"; break;
        case TokenType::BitOr: *out_ << "protoPython::TokenType::BitOr"; break;
        case TokenType::BitXor: *out_ << "protoPython::TokenType::BitXor"; break;
        case TokenType::LShift: *out_ << "protoPython::TokenType::LShift"; break;
        case TokenType::RShift: *out_ << "protoPython::TokenType::RShift"; break;
        case TokenType::DoubleStar: *out_ << "protoPython::TokenType::DoubleStar"; break;
        case TokenType::DoubleSlash: *out_ << "protoPython::TokenType::DoubleSlash"; break;
        case TokenType::At: *out_ << "protoPython::TokenType::At"; break;
        default: *out_ << "protoPython::TokenType::Plus /* Unsupported op */"; break;
    }
    *out_ << ", ";
    if (!generateNode(n->right.get())) return false;
    *out_ << ")";
    return true;
}

bool CppGenerator::generatePass(PassNode* n) {
    *out_ << "/* pass */";
    return true;
}

bool CppGenerator::generateBreak(BreakNode* n) {
    *out_ << "break";
    return true;
}

bool CppGenerator::generateContinue(ContinueNode* n) {
    *out_ << "continue";
    return true;
}

bool CppGenerator::generateFunctionDef(FunctionDefNode* n) {
    return generateFunctionInternal(n->name, n->parameters, n->vararg, n->kwarg, n->body.get(), n->decorator_list, false);
}

bool CppGenerator::generateAsyncFunctionDef(AsyncFunctionDefNode* n) {
    return generateFunctionInternal(n->name, n->parameters, n->vararg, n->kwarg, n->body.get(), n->decorator_list, true);
}

bool CppGenerator::generateFunctionInternal(const std::string& name, 
                                         const std::vector<std::string>& parameters,
                                         const std::string& vararg,
                                         const std::string& kwarg,
                                         ASTNode* body,
                                         const std::vector<std::unique_ptr<ASTNode>>& decorator_list,
                                         bool isAsync) {
    // Save state for nested functions
    bool oldInStateMachine = inStateMachine_;
    int oldStateCount = stateCount_;
    auto oldOrderedLocals = orderedLocalVars_;
    auto oldLocalVars = localVars_;

    // 1. Identify locals and check for yield/await
    localVars_.clear();
    orderedLocalVars_.clear();
    collectLocals(body, localVars_);
    
    // Sort locals for consistent state management
    std::vector<std::string> orderedLocals(localVars_.begin(), localVars_.end());
    std::sort(orderedLocals.begin(), orderedLocals.end());
    orderedLocalVars_ = orderedLocals;

    bool isGenerator = containsYieldOrAwait(body);
    
    // Use a unique suffix for top-level C++ function names
    static int functionCounter = 0;
    std::string uniqueSuffix = "_" + std::to_string(++functionCounter);
    std::string cppFuncName = "py_func_" + name + uniqueSuffix;
    std::string cppContName = "py_cont_" + name + uniqueSuffix;

    std::ostream* oldOut = out_;
    std::ostringstream funcStream;
    out_ = &funcStream;

    if (isGenerator) {
        stateCount_ = 0;
        inStateMachine_ = true;
        
        // 1. Generate Continuation Function at top level
        *out_ << "\nconst proto::ProtoObject* " << cppContName << "(proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) {\n";
        *out_ << "    auto* env = protoPython::PythonEnvironment::get(ctx);\n";
        *out_ << "    auto* gen = const_cast<proto::ProtoObject*>(self);\n";
        
        // Restore local variables from gi_locals
        *out_ << "    const proto::ProtoSparseList* gi_locals = env->getAttribute(ctx, gen, env->getGiLocalsString())->asSparseList(ctx);\n";
        int local_idx = 0;
        for (const auto& loc : orderedLocals) {
            *out_ << "    const proto::ProtoObject* local_" << loc << " = (gi_locals && " << local_idx << " < gi_locals->getSize(ctx)) ? gi_locals->getAt(ctx, " << local_idx << ") : PROTO_NONE;\n";
            local_idx++;
        }
        
        *out_ << "    int pc = env->getAttribute(ctx, gen, env->getGiPCString())->asLong(ctx);\n";
        *out_ << "    if (std::getenv(\"PROTO_ENV_DIAG\")) { fprintf(stderr, \"[cont] gen=%p pc=%d\\n\", (void*)gen, pc); fflush(stderr); }\n";
        *out_ << "    try {\n";
        *out_ << "        switch (pc) {\n";
        *out_ << "            case 0: \n";
        
        if (!generateNode(body)) return false;
        
        *out_ << "                break;\n";
        *out_ << "        }\n";
        *out_ << "    } catch (const proto::ProtoObject* val) {\n";
        *out_ << "        if (env->isStopIteration(val)) throw val;\n";
        *out_ << "        return val;\n";
        *out_ << "    }\n";
        
        *out_ << "    gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(-1));\n"; 
        *out_ << "    env->raiseStopIteration(ctx, PROTO_NONE);\n";
        *out_ << "    return PROTO_NONE;\n";
        *out_ << "}\n";

        // 2. Generate Wrapper Function at top level
        *out_ << "\nconst proto::ProtoObject* " << cppFuncName << "(proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) {\n";
        *out_ << "    auto* env = protoPython::PythonEnvironment::get(ctx);\n";
        *out_ << "    auto* gen = const_cast<proto::ProtoObject*>(ctx->newObject(true));\n";
        *out_ << "    if (env->getGeneratorPrototype()) gen->addParent(ctx, env->getGeneratorPrototype());\n";
        *out_ << "    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiNativeCallbackString(), ctx->fromMethod(nullptr, " << cppContName << ")));\n";
        *out_ << "    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(0)));\n";
        *out_ << "    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiRunningString(), PROTO_FALSE));\n";
        
        // Initial locals
        *out_ << "    const proto::ProtoSparseList* initialLocals = ctx->newSparseList();\n";
        for (size_t i = 0; i < orderedLocals.size(); ++i) {
            *out_ << "    initialLocals = initialLocals->setAt(ctx, " << i << ", PROTO_NONE);\n";
        }
        
        // Bind parameters to initial locals
        *out_ << "    unsigned long nPos = args ? args->getSize(ctx) : 0;\n";
        for (size_t i = 0; i < parameters.size(); ++i) {
             auto it = std::find(orderedLocals.begin(), orderedLocals.end(), parameters[i]);
             if (it != orderedLocals.end()) {
                 int idx = std::distance(orderedLocals.begin(), it);
                 *out_ << "    if (nPos > " << i << ") initialLocals = initialLocals->setAt(ctx, " << idx << ", args->getAt(ctx, " << i << "));\n";
             }
        }
        *out_ << "    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiLocalsString(), initialLocals->asObject(ctx)));\n";
        *out_ << "    return gen;\n";
        *out_ << "}\n";

        inStateMachine_ = false;
    } else {
        // Standard function logic
        *out_ << "\nconst proto::ProtoObject* " << cppFuncName << "(proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) {\n";
        *out_ << "    auto* env = protoPython::PythonEnvironment::get(ctx);\n";
        *out_ << "    unsigned long nPos = args ? args->getSize(ctx) : 0;\n";
        
        // Bind parameters
        for (size_t i = 0; i < parameters.size(); ++i) {
             *out_ << "    const proto::ProtoObject* local_" << parameters[i] << " = (nPos > " << i << ") ? args->getAt(ctx, " << i << ") : PROTO_NONE;\n";
        }
        // Initialize other locals
        for (const auto& loc : orderedLocals) {
            bool isParam = std::find(parameters.begin(), parameters.end(), loc) != parameters.end();
            if (!isParam) {
                *out_ << "    const proto::ProtoObject* local_" << loc << " = PROTO_NONE;\n";
            }
        }

        *out_ << "    try {\n";
        if (!generateNode(body)) return false;
        *out_ << "    } catch (const proto::ProtoObject* retVal) { return retVal; }\n";
        *out_ << "    return PROTO_NONE;\n";
        *out_ << "}\n";
    }

    // Append to header
    header_ << funcStream.str();

    // Registration in module init
    out_ = oldOut;
    *out_ << "    const proto::ProtoObject* func_" << name << " = ctx->fromMethod(nullptr, " << cppFuncName << ")";
    
    if (!decorator_list.empty()) {
        for (auto it = decorator_list.rbegin(); it != decorator_list.rend(); ++it) {
            *out_ << ";\n    func_" << name << " = env->callObject(";
            if (!generateNode(it->get())) return false;
            *out_ << ", {func_" << name << "})";
        }
    }

    *out_ << ";\n    env->storeName(\"" << name << "\", func_" << name << ")";

    // Restore state
    inStateMachine_ = oldInStateMachine;
    stateCount_ = oldStateCount;
    orderedLocalVars_ = oldOrderedLocals;
    localVars_ = oldLocalVars;

    return true;
}


bool CppGenerator::generateClassDef(ClassDefNode* n) {
    *out_ << "\n    // Class definition: " << n->name << "\n";
    *out_ << "    const proto::ProtoObject* class_name_" << n->name << " = ctx->fromUTF8String(\"" << n->name << "\");\n";
    
    // Bases
    *out_ << "    std::vector<const proto::ProtoObject*> bases_" << n->name << ";\n";
    for (auto& b : n->bases) {
        *out_ << "    bases_" << n->name << ".push_back(";
        if (!generateNode(b.get())) return false;
        *out_ << ");\n";
    }

    // Namespace and Body
    *out_ << "    auto* ns_" << n->name << " = const_cast<proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "    ns_" << n->name << "->setAttribute(ctx, env->getNameString(), class_name_" << n->name << ");\n";
    *out_ << "    {\n";
    *out_ << "        auto* oldFrame = protoPython::PythonEnvironment::getCurrentFrame();\n";
    *out_ << "        protoPython::PythonEnvironment::setCurrentFrame(ns_" << n->name << ");\n";
    if (!generateNode(n->body.get())) return false;
    *out_ << "        protoPython::PythonEnvironment::setCurrentFrame(oldFrame);\n";
    *out_ << "    }\n";

    // Create Class Object
    *out_ << "    auto* cls_" << n->name << " = const_cast<proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "    if (env->getTypePrototype()) cls_" << n->name << "->setAttribute(ctx, env->getClassString(), env->getTypePrototype());\n";
    *out_ << "    for (auto* b : bases_" << n->name << ") cls_" << n->name << "->addParent(ctx, b);\n";
    
    // Copy attributes from namespace to class
    *out_ << "    {\n";
    *out_ << "        const proto::ProtoSparseList* keys = ns_" << n->name << "->getAttributes(ctx);\n";
    *out_ << "        if (keys) {\n";
    *out_ << "            auto it = keys->getIterator(ctx);\n";
    *out_ << "            while (it && it->hasNext(ctx)) {\n";
    *out_ << "                unsigned long key = it->nextKey(ctx);\n";
    *out_ << "                const proto::ProtoObject* keyObj = reinterpret_cast<const proto::ProtoObject*>(key);\n";
    *out_ << "                if (keyObj && keyObj->isString(ctx)) {\n";
    *out_ << "                    const proto::ProtoString* k = keyObj->asString(ctx);\n";
    *out_ << "                    cls_" << n->name << "->setAttribute(ctx, k, ns_" << n->name << "->getAttribute(ctx, k));\n";
    *out_ << "                }\n";
    *out_ << "                it = const_cast<proto::ProtoSparseListIterator*>(it)->advance(ctx);\n";
    *out_ << "            }\n";
    *out_ << "        }\n";
    *out_ << "    }\n";
    
    // Set __call__ for instantiation
    *out_ << "    cls_" << n->name << "->setAttribute(ctx, env->getCallString(), ctx->fromMethod(cls_" << n->name << ", [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {\n";
    *out_ << "        auto* env = protoPython::PythonEnvironment::get(ctx);\n";
    *out_ << "        auto* obj = const_cast<proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "        obj->addParent(ctx, self);\n";
    *out_ << "        const proto::ProtoObject* init = env->getAttribute(ctx, obj, env->getInitString());\n";
    *out_ << "        if (init && init != PROTO_NONE) {\n";
    *out_ << "            std::vector<const proto::ProtoObject*> vargs;\n";
    *out_ << "            for (unsigned long i = 0; i < args->getSize(ctx); ++i) vargs.push_back(args->getAt(ctx, i));\n";
    *out_ << "            env->callObject(init, vargs);\n";
    *out_ << "        }\n";
    *out_ << "        return obj;\n";
    *out_ << "    }));\n";

    *out_ << "    auto var_cls_" << n->name << " = static_cast<const proto::ProtoObject*>(cls_" << n->name << ");\n";

    // Apply decorators Bottom-to-Top
    if (!n->decorator_list.empty()) {
        for (auto it = n->decorator_list.rbegin(); it != n->decorator_list.rend(); ++it) {
            *out_ << "    var_cls_" << n->name << " = env->callObject(";
            if (!generateNode(it->get())) return false;
            *out_ << ", {var_cls_" << n->name << "});\n";
        }
    }

    *out_ << "    env->storeName(\"" << n->name << "\", var_cls_" << n->name << ");\n";
    return true;
}

bool CppGenerator::generateAugAssign(AugAssignNode* n) {
    if (auto* nameNode = dynamic_cast<NameNode*>(n->target.get())) {
        *out_ << "env->augAssignName(\"" << nameNode->id << "\", ";
    } else if (auto* attrNode = dynamic_cast<AttributeNode*>(n->target.get())) {
        *out_ << "env->augAssignAttr(";
        if (!generateNode(attrNode->value.get())) return false;
        *out_ << ", \"" << attrNode->attr << "\", ";
    } else if (auto* subNode = dynamic_cast<SubscriptNode*>(n->target.get())) {
        *out_ << "env->augAssignItem(";
        if (!generateNode(subNode->value.get())) return false;
        *out_ << ", ";
        if (!generateNode(subNode->index.get())) return false;
        *out_ << ", ";
    } else {
        *out_ << "/* Unsupported augAssign target */";
        return true;
    }
    
    switch (n->op) {
        case TokenType::PlusAssign: *out_ << "protoPython::TokenType::PlusAssign"; break;
        case TokenType::MinusAssign: *out_ << "protoPython::TokenType::MinusAssign"; break;
        case TokenType::StarAssign: *out_ << "protoPython::TokenType::StarAssign"; break;
        case TokenType::SlashAssign: *out_ << "protoPython::TokenType::SlashAssign"; break;
        default: *out_ << "protoPython::TokenType::PlusAssign"; break;
    }
    *out_ << ", ";
    if (!generateNode(n->value.get())) return false;
    *out_ << ")";
    return true;
}

bool CppGenerator::generateReturn(ReturnNode* n) {
    if (inStateMachine_) {
        *out_ << "env->raiseStopIteration(ctx, ";
        if (n->value) {
            if (!generateNode(n->value.get())) return false;
        } else {
            *out_ << "PROTO_NONE";
        }
        *out_ << ")";
        return true;
    }
    *out_ << "throw ";
    if (n->value) {
        if (!generateNode(n->value.get())) return false;
    } else {
        *out_ << "PROTO_NONE";
    }
    return true;
}

bool CppGenerator::generateAttribute(AttributeNode* n) {
    *out_ << "env->getAttr(";
    if (!generateNode(n->value.get())) return false;
    *out_ << ", \"" << n->attr << "\")";
    return true;
}

bool CppGenerator::generateSubscript(SubscriptNode* n) {
    *out_ << "env->getItem(";
    if (!generateNode(n->value.get())) return false;
    *out_ << ", ";
    if (!generateNode(n->index.get())) return false;
    *out_ << ")";
    return true;
}

bool CppGenerator::generateListLiteral(ListLiteralNode* n) {
    *out_ << "([&]() {\n";
    *out_ << "        auto* listObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "        auto* lst = ctx->newList();\n";
    for (auto& elt : n->elements) {
        if (auto* s = dynamic_cast<StarredNode*>(elt.get())) {
            *out_ << "        {\n";
            *out_ << "            auto* unpacked = "; if (!generateNode(s->value.get())) return false; *out_ << ";\n";
            *out_ << "            auto* i = env->iter(unpacked);\n";
            *out_ << "            while (true) {\n";
            *out_ << "                auto* item = env->next(i);\n";
            *out_ << "                if (!item || item == PROTO_NONE) break;\n";
            *out_ << "                lst = lst->appendLast(ctx, item);\n";
            *out_ << "            }\n";
            *out_ << "        }\n";
        } else {
            *out_ << "        lst = lst->appendLast(ctx, ";
            if (!generateNode(elt.get())) return false;
            *out_ << ");\n";
        }
    }
    *out_ << "        listObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)lst);\n";
    *out_ << "        if (env->getListPrototype()) listObj->addParent(ctx, env->getListPrototype());\n";
    *out_ << "        return (const proto::ProtoObject*)listObj;\n";
    *out_ << "    })()";
    return true;
}

bool CppGenerator::generateDictLiteral(DictLiteralNode* n) {
    *out_ << "([&]() {\n";
    *out_ << "        auto* mapObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "        auto* data = ctx->newSparseList();\n";
    *out_ << "        auto* keys = ctx->newList();\n";
    for (size_t i = 0; i < n->keys.size(); ++i) {
        if (n->keys[i] == nullptr) {
            // Unpacking: **v
            *out_ << "        {\n";
            *out_ << "            auto* unpacked = "; 
            if (auto* starred = dynamic_cast<protoPython::StarredNode*>(n->values[i].get())) {
                if (!generateNode(starred->value.get())) return false;
            } else {
                if (!generateNode(n->values[i].get())) return false;
            }
            *out_ << ";\n";
            *out_ << "            auto* i = env->iter(unpacked);\n";
            *out_ << "            while (true) {\n";
            *out_ << "                auto* k = env->next(i);\n";
            *out_ << "                if (!k || k == PROTO_NONE) break;\n";
            *out_ << "                auto* v = env->getItem(unpacked, k);\n";
            *out_ << "                data = data->setAt(ctx, k->getHash(ctx), v);\n";
            *out_ << "                keys = keys->appendLast(ctx, k);\n";
            *out_ << "            }\n";
            *out_ << "        }\n";
        } else {
            *out_ << "        {\n";
            *out_ << "            auto* k = "; if (!generateNode(n->keys[i].get())) return false; *out_ << ";\n";
            *out_ << "            auto* v = "; if (!generateNode(n->values[i].get())) return false; *out_ << ";\n";
            *out_ << "            data = data->setAt(ctx, k->getHash(ctx), v);\n";
            *out_ << "            keys = keys->appendLast(ctx, k);\n";
            *out_ << "        }\n";
        }
    }
    *out_ << "        mapObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)data);\n";
    *out_ << "        mapObj->setAttribute(ctx, env->getKeysString(), (const proto::ProtoObject*)keys);\n";
    *out_ << "        if (env->getDictPrototype()) mapObj->addParent(ctx, env->getDictPrototype());\n";
    *out_ << "        return (const proto::ProtoObject*)mapObj;\n";
    *out_ << "    })()";
    return true;
}

bool CppGenerator::generateTupleLiteral(TupleLiteralNode* n) {
    *out_ << "([&]() {\n";
    *out_ << "        auto* tupObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "        auto* lst = ctx->newList();\n";
    for (auto& elt : n->elements) {
        if (auto* s = dynamic_cast<StarredNode*>(elt.get())) {
            *out_ << "        {\n";
            *out_ << "            auto* unpacked = "; if (!generateNode(s->value.get())) return false; *out_ << ";\n";
            *out_ << "            auto* i = env->iter(unpacked);\n";
            *out_ << "            while (true) {\n";
            *out_ << "                auto* item = env->next(i);\n";
            *out_ << "                if (!item || item == PROTO_NONE) break;\n";
            *out_ << "                lst = lst->appendLast(ctx, item);\n";
            *out_ << "            }\n";
            *out_ << "        }\n";
        } else {
            *out_ << "        lst = lst->appendLast(ctx, ";
            if (!generateNode(elt.get())) return false;
            *out_ << ");\n";
        }
    }
    *out_ << "        auto* tup = ctx->newTupleFromList(lst);\n";
    *out_ << "        tupObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)tup);\n";
    *out_ << "        if (env->getTuplePrototype()) tupObj->addParent(ctx, env->getTuplePrototype());\n";
    *out_ << "        return (const proto::ProtoObject*)tupObj;\n";
    *out_ << "    })()";
    return true;
}

bool CppGenerator::generateSetLiteral(SetLiteralNode* n) {
    *out_ << "([&]() {\n";
    *out_ << "        auto* setObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    *out_ << "        auto* data = ctx->newSparseList();\n";
    for (auto& elt : n->elements) {
        if (auto* s = dynamic_cast<StarredNode*>(elt.get())) {
            *out_ << "        {\n";
            *out_ << "            auto* unpacked = "; if (!generateNode(s->value.get())) return false; *out_ << ";\n";
            *out_ << "            auto* i = env->iter(unpacked);\n";
            *out_ << "            while (true) {\n";
            *out_ << "                auto* item = env->next(i);\n";
            *out_ << "                if (!item || item == PROTO_NONE) break;\n";
            *out_ << "                data = data->setAt(ctx, item->getHash(ctx), item);\n";
            *out_ << "            }\n";
            *out_ << "        }\n";
        } else {
            *out_ << "        {\n";
            *out_ << "            auto* e = "; if (!generateNode(elt.get())) return false; *out_ << ";\n";
            *out_ << "            data = data->setAt(ctx, e->getHash(ctx), e);\n";
            *out_ << "        }\n";
        }
    }
    *out_ << "        setObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)data);\n";
    *out_ << "        if (env->getSetPrototype()) setObj->addParent(ctx, env->getSetPrototype());\n";
    *out_ << "        return (const proto::ProtoObject*)setObj;\n";
    *out_ << "    })()";
    return true;
}

bool CppGenerator::generateNamedExpr(NamedExprNode* n) {
    *out_ << "([&]() {\n";
    *out_ << "        const proto::ProtoObject* val = ";
    if (!generateNode(n->value.get())) return false;
    *out_ << ";\n";
    if (!generateAssignToTarget(n->target.get(), "val")) return false;
    *out_ << ";\n";
    *out_ << "        return val;\n";
    *out_ << "    })()";
    return true;
}

bool CppGenerator::generateFor(ForNode* n) {
    static int forId = 0;
    int id = forId++;
    *out_ << "{\n";
    *out_ << "        auto* __iter_" << id << " = env->iter(";
    if (!generateNode(n->iter.get())) return false;
    *out_ << ");\n";
    *out_ << "        while (true) {\n";
    *out_ << "            auto* __val_" << id << " = env->next(__iter_" << id << ");\n";
    *out_ << "            if (env->hasPendingException()) {\n";
    *out_ << "                (void)env->takePendingException();\n";
    *out_ << "                break;\n";
    *out_ << "            }\n";
    *out_ << "            if (!__val_" << id << " || __val_" << id << " == PROTO_NONE) {\n";
    if (n->orelse) {
        if (!generateNode(n->orelse.get())) return false;
        *out_ << ";\n";
    }
    *out_ << "                break;\n";
    *out_ << "            }\n";
    
    // Bind target
    if (auto* nameNode = dynamic_cast<NameNode*>(n->target.get())) {
        *out_ << "            env->storeName(\"" << nameNode->id << "\", __val_" << id << ");\n";
    } else if (auto* tupleNode = dynamic_cast<TupleLiteralNode*>(n->target.get())) {
        // Handle unpacking in for target: for x, y in ...
        std::ostringstream targetStream;
        targetStream << "__val_" << id;
        if (!generateAssignToTarget(tupleNode, targetStream.str())) return false;
        *out_ << ";\n";
    }
    
    if (!generateNode(n->body.get())) return false;
    *out_ << "        }\n";
    *out_ << "    }";
    return true;
}

bool CppGenerator::generateTry(TryNode* n) {
    *out_ << "{\n";
    if (!generateNode(n->body.get())) return false;
    *out_ << "        if (env->hasPendingException()) {\n";
    *out_ << "            auto* __exc = env->takePendingException();\n";
    *out_ << "            bool __handled = false;\n";
    for (auto& h : n->handlers) {
        *out_ << "            if (!__handled";
        if (h.type) {
            *out_ << " && env->isException(__exc, ";
            if (!generateNode(h.type.get())) return false;
            *out_ << ")";
        }
        *out_ << ") {\n";
        *out_ << "                __handled = true;\n";
        if (!h.name.empty()) {
            *out_ << "                env->storeName(\"" << h.name << "\", __exc);\n";
        }
        if (!generateNode(h.body.get())) return false;
        *out_ << "            }\n";
    }
    *out_ << "            if (!__handled) env->raiseException(__exc);\n";
    *out_ << "        }\n";
    if (n->finalbody) {
        *out_ << "        // finally\n";
        if (!generateNode(n->finalbody.get())) return false;
    }
    *out_ << "    }";
    return true;
}

bool CppGenerator::generateRaise(RaiseNode* n) {
    if (n->exc) {
        *out_ << "env->raiseException(";
        if (!generateNode(n->exc.get())) return false;
        *out_ << ")";
    } else {
        *out_ << "/* re-raise unsupported */";
    }
    return true;
}

bool CppGenerator::generateWith(WithNode* n) {
    *out_ << "/* with statement simplified */\n";
    for (auto& item : n->items) {
        if (!generateNode(item.context_expr.get())) return false;
        *out_ << ";\n";
    }
    if (!generateNode(n->body.get())) return false;
    return true;
}

bool CppGenerator::generateImport(ImportNode* n) {
    *out_ << "{\n";
    *out_ << "        const proto::ProtoObject* __mod = env->importModule(\"" << n->moduleName << "\");\n";
    if (n->isAs) {
        *out_ << "        env->storeName(\"" << n->alias << "\", __mod);\n";
    } else {
        size_t dot = n->moduleName.find('.');
        std::string root = (dot == std::string::npos) ? n->moduleName : n->moduleName.substr(0, dot);
        *out_ << "        env->storeName(\"" << root << "\", __mod);\n";
    }
    *out_ << "    }";
    return true;
}

bool CppGenerator::generateImportFrom(ImportFromNode* n) {
    *out_ << "{\n";
    *out_ << "        const proto::ProtoObject* __mod = env->importModule(\"" << n->moduleName << "\", " << n->level << ", {";
    for (size_t i = 0; i < n->names.size(); ++i) {
        *out_ << "\"" << n->names[i].first << "\"";
        if (i < n->names.size() - 1) *out_ << ", ";
    }
    *out_ << "});\n";
    if (n->names.size() == 1 && n->names[0].first == "*") {
        *out_ << "        env->importStar(__mod);\n";
    } else {
        for (auto& p : n->names) {
            std::string alias = p.second.empty() ? p.first : p.second;
            *out_ << "        env->storeName(\"" << alias << "\", env->getAttr(__mod, \"" << p.first << "\"));\n";
        }
    }
    *out_ << "    }";
    return true;
}

bool CppGenerator::generateLambda(LambdaNode* n) {
    if (!n) return false;
    *out_ << "ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {\n";
    *out_ << "        auto* env = protoPython::PythonEnvironment::get(ctx);\n";
    *out_ << "        // Bind parameters\n";
    *out_ << "        unsigned long nPos = args ? args->getSize(ctx) : 0;\n";
    for (size_t i = 0; i < n->parameters.size(); ++i) {
        *out_ << "        if (nPos > " << i << ") env->storeName(\"" << n->parameters[i] << "\", args->getAt(ctx, " << i << "));\n";
    }

    if (!n->vararg.empty()) {
        *out_ << "        const proto::ProtoList* vaList = ctx->newList();\n";
        *out_ << "        for (unsigned long i = " << n->parameters.size() << "; i < nPos; ++i) vaList = vaList->appendLast(ctx, args->getAt(ctx, i));\n";
        *out_ << "        auto* vaTup = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
        *out_ << "        vaTup->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)ctx->newTupleFromList(vaList));\n";
        *out_ << "        if (env->getTuplePrototype()) vaTup->addParent(ctx, env->getTuplePrototype());\n";
        *out_ << "        env->storeName(\"" << n->vararg << "\", vaTup);\n";
    }

    if (!n->kwarg.empty()) {
        *out_ << "        auto* kaDict = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
        *out_ << "        kaDict->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)(kwargs ? kwargs : ctx->newSparseList()));\n";
        *out_ << "        const proto::ProtoTuple* kwNames = env->getCurrentKwNames();\n";
        *out_ << "        if (kwNames) kaDict->setAttribute(ctx, env->getKeysString(), (const proto::ProtoObject*)kwNames->asList(ctx));\n";
        *out_ << "        if (env->getDictPrototype()) kaDict->addParent(ctx, env->getDictPrototype());\n";
        *out_ << "        env->storeName(\"" << n->kwarg << "\", kaDict);\n";
    }

    *out_ << "        return ";
    if (!generateNode(n->body.get())) return false;
    *out_ << ";\n";
    *out_ << "    })";
    return true;
}

bool CppGenerator::generateJoinedStr(JoinedStrNode* n) {
    if (!n) return false;
    *out_ << "env->buildString({";
    for (size_t i = 0; i < n->values.size(); ++i) {
        if (!generateNode(n->values[i].get())) return false;
        if (i < n->values.size() - 1) *out_ << ", ";
    }
    *out_ << "})";
    return true;
}

bool CppGenerator::generateFormattedValue(FormattedValueNode* n) {
    if (!n) return false;
    return generateNode(n->value.get());
}

bool CppGenerator::generateSlice(SliceNode* n) {
    *out_ << "env->buildSlice(";
    if (n->start) { if (!generateNode(n->start.get())) return false; } else { *out_ << "PROTO_NONE"; }
    *out_ << ", ";
    if (n->stop) { if (!generateNode(n->stop.get())) return false; } else { *out_ << "PROTO_NONE"; }
    *out_ << ", ";
    if (n->step) { if (!generateNode(n->step.get())) return false; } else { *out_ << "PROTO_NONE"; }
    *out_ << ")";
    return true;
}

bool CppGenerator::generateDeleteNode(DeleteNode* n) {
    for (auto& target : n->targets) {
        if (auto* nm = dynamic_cast<NameNode*>(target.get())) {
            *out_ << "env->delName(\"" << nm->id << "\")";
        } else if (auto* att = dynamic_cast<AttributeNode*>(target.get())) {
            *out_ << "env->delAttr(";
            if (!generateNode(att->value.get())) return false;
            *out_ << ", \"" << att->attr << "\")";
        } else if (auto* sub = dynamic_cast<SubscriptNode*>(target.get())) {
            *out_ << "env->delItem(";
            if (!generateNode(sub->value.get())) return false;
            *out_ << ", ";
            if (!generateNode(sub->index.get())) return false;
            *out_ << ")";
        }
        *out_ << ";\n";
    }
    return true;
}

bool CppGenerator::generateAssert(AssertNode* n) {
    *out_ << "if (!env->isTrue(";
    if (!generateNode(n->test.get())) return false;
    *out_ << ")) {\n";
    *out_ << "        env->raiseAssertionError(ctx, ";
    if (n->msg) { if (!generateNode(n->msg.get())) return false; } else { *out_ << "nullptr"; }
    *out_ << ");\n";
    *out_ << "    }";
    return true;
}

bool CppGenerator::generateYield(YieldNode* n) {
    if (!inStateMachine_) {
        *out_ << "env->raiseException(ctx->fromUTF8String(\"SyntaxError: 'yield' outside function\"))";
        return true;
    }
    
    int nextPC = ++stateCount_;
    
    // 1. Save local variables to gi_locals
    *out_ << "            {\n";
    *out_ << "                const proto::ProtoSparseList* locals = ctx->newSparseList();\n";
    int local_idx = 0;
    for (const auto& loc : orderedLocalVars_) {
        *out_ << "                locals = locals->setAt(ctx, " << local_idx++ << ", local_" << loc << ");\n";
    }
    *out_ << "                gen->setAttribute(ctx, env->getGiLocalsString(), locals->asObject(ctx));\n";
    *out_ << "            }\n";
    
    // 2. Save PC
    *out_ << "            gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(" << nextPC << "));\n";
    
    // 3. Return yield value
    *out_ << "            throw ";
    if (n->value) {
        if (!generateNode(n->value.get())) return false;
    } else {
        *out_ << "PROTO_NONE";
    }
    *out_ << ";\n";
    
    // 4. Case label for continuation
    *out_ << "        case " << nextPC << ":\n";
    *out_ << "            /* resumed from yield */\n";
    *out_ << "            if (std::getenv(\"PROTO_ENV_DIAG\")) { fprintf(stderr, \"[cont] resumed yield pc=" << nextPC << "\\n\"); fflush(stderr); }\n";
    *out_ << "            ([&]() -> const proto::ProtoObject* {\n";
    *out_ << "                return (args && args->getSize(ctx) > 1) ? args->getAt(ctx, 1) : PROTO_NONE;\n";
    *out_ << "            })()";
    
    return true;
}

bool CppGenerator::generateAwait(AwaitNode* n) {
    if (!inStateMachine_) {
        *out_ << "env->raiseException(ctx->fromUTF8String(\"SyntaxError: 'await' outside function\"))";
        return true;
    }
    
    // Await is similar to yield in our native implementation:
    // It yields the awaitable, and the scheduler will send back the result.
    int nextPC = ++stateCount_;
    
    // 1. Save locals
    *out_ << "            {\n";
    *out_ << "                const proto::ProtoSparseList* locals = ctx->newSparseList();\n";
    int local_idx = 0;
    for (const auto& loc : orderedLocalVars_) {
        *out_ << "                locals = locals->setAt(ctx, " << local_idx++ << ", local_" << loc << ");\n";
    }
    *out_ << "                gen->setAttribute(ctx, env->getGiLocalsString(), locals->asObject(ctx));\n";
    *out_ << "            }\n";
    
    // 2. Save PC
    *out_ << "            gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(" << nextPC << "));\n";
    
    // 3. Throw the awaitable (the scheduler/send implementation will handle it)
    *out_ << "            throw ";
    if (!generateNode(n->value.get())) return false;
    *out_ << ";\n";
    
    // 4. Case label for continuation
    *out_ << "        case " << nextPC << ":\n";
    *out_ << "            /* resumed from await, args[0] is the sent value */\n";
    *out_ << "            if (std::getenv(\"PROTO_ENV_DIAG\")) { fprintf(stderr, \"[cont] resumed await pc=" << nextPC << "\\n\"); fflush(stderr); }\n";
    *out_ << "            ([&]() -> const proto::ProtoObject* {\n";
    *out_ << "                return (args && args->getSize(ctx) > 1) ? args->getAt(ctx, 1) : PROTO_NONE;\n";
    *out_ << "            })()";
    
    return true;
}

void CppGenerator::collectLocals(ASTNode* node, std::unordered_set<std::string>& locals) {
    if (!node) return;
    if (auto* n = dynamic_cast<AssignNode*>(node)) {
        for (auto& t : n->targets) {
            if (auto* name = dynamic_cast<NameNode*>(t.get())) locals.insert(name->id);
            else collectLocals(t.get(), locals);
        }
    }
 else if (auto* n = dynamic_cast<ForNode*>(node)) {
        if (auto* name = dynamic_cast<NameNode*>(n->target.get())) locals.insert(name->id);
        collectLocals(n->body.get(), locals);
    } else if (auto* n = dynamic_cast<SuiteNode*>(node)) {
        for (auto& stmt : n->statements) collectLocals(stmt.get(), locals);
    } else if (auto* n = dynamic_cast<IfNode*>(node)) {
        collectLocals(n->body.get(), locals);
        if (n->orelse) collectLocals(n->orelse.get(), locals);
    } else if (auto* n = dynamic_cast<WhileNode*>(node)) {
        collectLocals(n->body.get(), locals);
        if (n->orelse) collectLocals(n->orelse.get(), locals);
    } else if (auto* n = dynamic_cast<TryNode*>(node)) {
        collectLocals(n->body.get(), locals);
        for (auto& h : n->handlers) {
            if (!h.name.empty()) locals.insert(h.name);
            collectLocals(h.body.get(), locals);
        }
        if (n->finalbody) collectLocals(n->finalbody.get(), locals);
    }
}

bool CppGenerator::containsYieldOrAwait(ASTNode* node) {
    if (!node) return false;
    if (dynamic_cast<YieldNode*>(node)) return true;
    if (dynamic_cast<AwaitNode*>(node)) return true;
    
    if (auto* n = dynamic_cast<SuiteNode*>(node)) {
        for (auto& stmt : n->statements) if (containsYieldOrAwait(stmt.get())) return true;
    } else if (auto* n = dynamic_cast<IfNode*>(node)) {
        if (containsYieldOrAwait(n->test.get())) return true;
        if (containsYieldOrAwait(n->body.get())) return true;
        if (n->orelse && containsYieldOrAwait(n->orelse.get())) return true;
    } else if (auto* n = dynamic_cast<WhileNode*>(node)) {
        if (containsYieldOrAwait(n->test.get())) return true;
        if (containsYieldOrAwait(n->body.get())) return true;
        if (n->orelse && containsYieldOrAwait(n->orelse.get())) return true;
    } else if (auto* n = dynamic_cast<ForNode*>(node)) {
        if (containsYieldOrAwait(n->iter.get())) return true;
        if (containsYieldOrAwait(n->body.get())) return true;
    } else if (auto* n = dynamic_cast<TryNode*>(node)) {
        if (containsYieldOrAwait(n->body.get())) return true;
        for (auto& h : n->handlers) if (containsYieldOrAwait(h.body.get())) return true;
        if (n->finalbody && containsYieldOrAwait(n->finalbody.get())) return true;
    } else if (auto* n = dynamic_cast<CallNode*>(node)) {
        if (containsYieldOrAwait(n->func.get())) return true;
        for (auto& arg : n->args) if (containsYieldOrAwait(arg.get())) return true;
    } else if (auto* n = dynamic_cast<AssignNode*>(node)) {
        for (auto& t : n->targets) if (containsYieldOrAwait(t.get())) return true;
        if (containsYieldOrAwait(n->value.get())) return true;
    } else if (auto* n = dynamic_cast<BinOpNode*>(node)) {
        if (containsYieldOrAwait(n->left.get())) return true;
        if (containsYieldOrAwait(n->right.get())) return true;
    } else if (auto* n = dynamic_cast<UnaryOpNode*>(node)) {
        if (containsYieldOrAwait(n->operand.get())) return true;
    } else if (auto* n = dynamic_cast<ReturnNode*>(node)) {
        if (n->value && containsYieldOrAwait(n->value.get())) return true;
    }
    return false;
}

} // namespace protoPython
