#include <protoPython/CppGenerator.h>

namespace protoPython {

bool CppGenerator::generate(ModuleNode* module, const std::string& filename) {
    out_ << "// Generated by protopyc from " << filename << "\n";
    out_ << "#include <protoCore.h>\n";
    out_ << "#include <protoPython/PythonEnvironment.h>\n";
    out_ << "#include <protoPython/Tokenizer.h>\n\n";
    out_ << "extern \"C\" void* proto_module_init() {\n";
    out_ << "    auto* ctx = protoPython::PythonEnvironment::getCurrentContext();\n";
    out_ << "    auto* env = protoPython::PythonEnvironment::get(ctx);\n\n";

    for (auto& stmt : module->body) {
        if (stmt->line > 0) emitLineDirective(stmt->line, filename);
        if (!generateNode(stmt.get())) return false;
        out_ << ";\n";
    }
    
    out_ << "    return nullptr;\n";
    out_ << "}\n";
    
    return true;
}

void CppGenerator::emitLineDirective(int line, const std::string& filename) {
    out_ << "#line " << line << " \"" << filename << "\"\n";
}

bool CppGenerator::generateNode(ASTNode* node) {
    if (auto* n = dynamic_cast<ConstantNode*>(node)) {
        return generateConstant(n);
    } else if (auto* n = dynamic_cast<NameNode*>(node)) {
        return generateName(n);
    } else if (auto* n = dynamic_cast<CallNode*>(node)) {
        return generateCall(n);
    } else if (auto* n = dynamic_cast<SuiteNode*>(node)) {
        for (auto& stmt : n->statements) {
            if (stmt->line > 0) emitLineDirective(stmt->line, "source.py"); // TODO
            if (!generateNode(stmt.get())) return false;
            out_ << ";\n";
        }
        return true;
    } else if (auto* n = dynamic_cast<AssignNode*>(node)) {
        return generateAssign(n);
    } else if (auto* n = dynamic_cast<IfNode*>(node)) {
        return generateIf(n);
    } else if (auto* n = dynamic_cast<BinOpNode*>(node)) {
        return generateBinOp(n);
    } else if (auto* n = dynamic_cast<PassNode*>(node)) {
        return generatePass(n);
    } else if (auto* n = dynamic_cast<BreakNode*>(node)) {
        return generateBreak(n);
    } else if (auto* n = dynamic_cast<ContinueNode*>(node)) {
        return generateContinue(n);
    } else if (auto* n = dynamic_cast<FunctionDefNode*>(node)) {
        return generateFunctionDef(n);
    } else if (auto* n = dynamic_cast<ReturnNode*>(node)) {
        return generateReturn(n);
    } else if (auto* n = dynamic_cast<AttributeNode*>(node)) {
        return generateAttribute(n);
    } else if (auto* n = dynamic_cast<SubscriptNode*>(node)) {
        return generateSubscript(n);
    } else if (auto* n = dynamic_cast<ListLiteralNode*>(node)) {
        return generateListLiteral(n);
    } else if (auto* n = dynamic_cast<DictLiteralNode*>(node)) {
        return generateDictLiteral(n);
    } else if (auto* n = dynamic_cast<TupleLiteralNode*>(node)) {
        return generateTupleLiteral(n);
    }
    
    out_ << "/* Unsupported node: " << typeid(*node).name() << " */";
    return true; 
}

bool CppGenerator::generateConstant(ConstantNode* n) {
    switch (n->constType) {
        case ConstantNode::ConstType::Int:
            out_ << "ctx->fromInteger(" << n->intVal << ")";
            break;
        case ConstantNode::ConstType::Float:
            out_ << "ctx->fromDouble(" << n->floatVal << ")";
            break;
        case ConstantNode::ConstType::Str:
            out_ << "ctx->fromUTF8String(\"" << n->strVal << "\")";
            break;
        case ConstantNode::ConstType::Bool:
            out_ << (n->intVal ? "PROTO_TRUE" : "PROTO_FALSE");
            break;
        case ConstantNode::ConstType::None:
            out_ << "PROTO_NONE";
            break;
    }
    return true;
}

bool CppGenerator::generateName(NameNode* n) {
    out_ << "env->lookupName(\"" << n->id << "\")";
    return true;
}

bool CppGenerator::generateCall(CallNode* n) {
    out_ << "env->callObject(";
    if (!generateNode(n->func.get())) return false;
    out_ << ", {";
    for (size_t i = 0; i < n->args.size(); ++i) {
        if (i > 0) out_ << ", ";
        if (!generateNode(n->args[i].get())) return false;
    }
    out_ << "})";
    return true;
}

bool CppGenerator::generateAssign(AssignNode* n) {
    if (auto* nameNode = dynamic_cast<NameNode*>(n->target.get())) {
        out_ << "env->storeName(\"" << nameNode->id << "\", ";
        if (!generateNode(n->value.get())) return false;
        out_ << ")";
        return true;
    } else if (auto* attrNode = dynamic_cast<AttributeNode*>(n->target.get())) {
        out_ << "env->setAttr(";
        if (!generateNode(attrNode->value.get())) return false;
        out_ << ", \"" << attrNode->attr << "\", ";
        if (!generateNode(n->value.get())) return false;
        out_ << ")";
        return true;
    } else if (auto* subNode = dynamic_cast<SubscriptNode*>(n->target.get())) {
        out_ << "env->setItem(";
        if (!generateNode(subNode->value.get())) return false;
        out_ << ", ";
        if (!generateNode(subNode->index.get())) return false;
        out_ << ", ";
        if (!generateNode(n->value.get())) return false;
        out_ << ")";
        return true;
    }
    out_ << "/* Unsupported assignment target */";
    return true;
}

bool CppGenerator::generateIf(IfNode* n) {
    out_ << "if (env->isTrue(";
    if (!generateNode(n->test.get())) return false;
    out_ << ")) {\n";
    if (!generateNode(n->body.get())) return false;
    out_ << ";\n}";
    if (n->orelse) {
        out_ << " else {\n";
        if (!generateNode(n->orelse.get())) return false;
        out_ << ";\n}";
    }
    return true;
}

bool CppGenerator::generateBinOp(BinOpNode* n) {
    out_ << "env->binaryOp(";
    if (!generateNode(n->left.get())) return false;
    out_ << ", ";
    switch (n->op) {
        case TokenType::Plus: out_ << "protoPython::TokenType::Plus"; break;
        case TokenType::Minus: out_ << "protoPython::TokenType::Minus"; break;
        case TokenType::Star: out_ << "protoPython::TokenType::Star"; break;
        case TokenType::Slash: out_ << "protoPython::TokenType::Slash"; break;
        case TokenType::Modulo: out_ << "protoPython::TokenType::Modulo"; break;
        case TokenType::EqEqual: out_ << "protoPython::TokenType::EqEqual"; break;
        case TokenType::NotEqual: out_ << "protoPython::TokenType::NotEqual"; break;
        case TokenType::Less: out_ << "protoPython::TokenType::Less"; break;
        case TokenType::LessEqual: out_ << "protoPython::TokenType::LessEqual"; break;
        case TokenType::Greater: out_ << "protoPython::TokenType::Greater"; break;
        case TokenType::GreaterEqual: out_ << "protoPython::TokenType::GreaterEqual"; break;
        default: out_ << "protoPython::TokenType::Plus /* Unsupported op */"; break;
    }
    out_ << ", ";
    if (!generateNode(n->right.get())) return false;
    out_ << ")";
    return true;
}

bool CppGenerator::generatePass(PassNode* n) {
    out_ << "/* pass */";
    return true;
}

bool CppGenerator::generateBreak(BreakNode* n) {
    out_ << "break";
    return true;
}

bool CppGenerator::generateContinue(ContinueNode* n) {
    out_ << "continue";
    return true;
}

bool CppGenerator::generateFunctionDef(FunctionDefNode* n) {
    // Generate the C++ function body
    out_ << "\n    auto func_" << n->name << " = ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {\n";
    out_ << "        auto* env = protoPython::PythonEnvironment::get(ctx);\n";
    out_ << "        // Bind parameters\n";
    for (size_t i = 0; i < n->parameters.size(); ++i) {
        out_ << "        if (args->getSize(ctx) > " << i << ") env->storeName(\"" << n->parameters[i] << "\", args->getAt(ctx, " << i << "));\n";
    }
    out_ << "        try {\n";
    if (n->body->line > 0) emitLineDirective(n->body->line, "source.py");
    if (!generateNode(n->body.get())) return false;
    out_ << "        } catch (const proto::ProtoObject* retVal) { return retVal; }\n";
    out_ << "        return PROTO_NONE;\n";
    out_ << "    });\n";
    out_ << "    env->storeName(\"" << n->name << "\", func_" << n->name << ");\n";
    return true;
}

bool CppGenerator::generateReturn(ReturnNode* n) {
    out_ << "throw ";
    if (n->value) {
        if (!generateNode(n->value.get())) return false;
    } else {
        out_ << "PROTO_NONE";
    }
    return true;
}

bool CppGenerator::generateAttribute(AttributeNode* n) {
    out_ << "env->getAttr(";
    if (!generateNode(n->value.get())) return false;
    out_ << ", \"" << n->attr << "\")";
    return true;
}

bool CppGenerator::generateSubscript(SubscriptNode* n) {
    out_ << "env->getItem(";
    if (!generateNode(n->value.get())) return false;
    out_ << ", ";
    if (!generateNode(n->index.get())) return false;
    out_ << ")";
    return true;
}

bool CppGenerator::generateListLiteral(ListLiteralNode* n) {
    out_ << "([&]() {\n";
    out_ << "        auto* listObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    out_ << "        auto* lst = ctx->newList();\n";
    for (auto& elt : n->elements) {
        out_ << "        lst = lst->appendLast(ctx, ";
        if (!generateNode(elt.get())) return false;
        out_ << ");\n";
    }
    out_ << "        listObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)lst);\n";
    out_ << "        if (env->getListPrototype()) listObj->addParent(ctx, env->getListPrototype());\n";
    out_ << "        return (const proto::ProtoObject*)listObj;\n";
    out_ << "    })()";
    return true;
}

bool CppGenerator::generateDictLiteral(DictLiteralNode* n) {
    out_ << "([&]() {\n";
    out_ << "        auto* mapObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    out_ << "        auto* data = ctx->newSparseList();\n";
    out_ << "        auto* keys = ctx->newList();\n";
    for (size_t i = 0; i < n->keys.size(); ++i) {
        out_ << "        {\n";
        out_ << "            auto* k = "; if (!generateNode(n->keys[i].get())) return false; out_ << ";\n";
        out_ << "            auto* v = "; if (!generateNode(n->values[i].get())) return false; out_ << ";\n";
        out_ << "            data = data->setAt(ctx, k->getHash(ctx), v);\n";
        out_ << "            keys = keys->appendLast(ctx, k);\n";
        out_ << "        }\n";
    }
    out_ << "        mapObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)data);\n";
    out_ << "        mapObj->setAttribute(ctx, env->getKeysString(), (const proto::ProtoObject*)keys);\n";
    out_ << "        if (env->getDictPrototype()) mapObj->addParent(ctx, env->getDictPrototype());\n";
    out_ << "        return (const proto::ProtoObject*)mapObj;\n";
    out_ << "    })()";
    return true;
}

bool CppGenerator::generateTupleLiteral(TupleLiteralNode* n) {
    out_ << "([&]() {\n";
    out_ << "        auto* tupObj = static_cast<const proto::ProtoObject*>(ctx->newObject(true));\n";
    out_ << "        auto* lst = ctx->newList();\n";
    for (auto& elt : n->elements) {
        out_ << "        lst = lst->appendLast(ctx, ";
        if (!generateNode(elt.get())) return false;
        out_ << ");\n";
    }
    out_ << "        auto* tup = ctx->newTupleFromList(lst);\n";
    out_ << "        tupObj->setAttribute(ctx, env->getDataString(), (const proto::ProtoObject*)tup);\n";
    out_ << "        if (env->getTuplePrototype()) tupObj->addParent(ctx, env->getTuplePrototype());\n";
    out_ << "        return (const proto::ProtoObject*)tupObj;\n";
    out_ << "    })()";
    return true;
}

} // namespace protoPython
