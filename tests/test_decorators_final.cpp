// Generated by protopyc from test_decorators_final.py
#include <protoCore.h>
#include <protoPython/PythonEnvironment.h>
#include <protoPython/Tokenizer.h>

extern "C" void* proto_module_init() {
    auto* ctx = protoPython::PythonEnvironment::getCurrentContext();
    auto* env = protoPython::PythonEnvironment::get(ctx);

#line 1 "test_decorators_final.py"

    auto func_dec = ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {
        auto* env = protoPython::PythonEnvironment::get(ctx);
        // Bind parameters
        if (args->getSize(ctx) > 0) env->storeName("f", args->getAt(ctx, 0));
        try {
#line 2 "source.py"
#line 2 "source.py"
env->callObject(env->lookupName("print"), {ctx->fromUTF8String("Decorating function")});
#line 3 "source.py"

    auto func_wrap = ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {
        auto* env = protoPython::PythonEnvironment::get(ctx);
        // Bind parameters
        if (args->getSize(ctx) > 0) env->storeName("a", args->getAt(ctx, 0));
        try {
#line 4 "source.py"
#line 4 "source.py"
throw env->binaryOp(env->callObject(env->lookupName("f"), {env->lookupName("a")}), protoPython::TokenType::Plus, ctx->fromInteger(1));
        } catch (const proto::ProtoObject* retVal) { return retVal; }
        return PROTO_NONE;
    });
    env->storeName("wrap", func_wrap);
;
#line 5 "source.py"
throw env->lookupName("wrap");
        } catch (const proto::ProtoObject* retVal) { return retVal; }
        return PROTO_NONE;
    });
    env->storeName("dec", func_dec);
;
#line 8 "test_decorators_final.py"

    auto func_double = ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {
        auto* env = protoPython::PythonEnvironment::get(ctx);
        // Bind parameters
        if (args->getSize(ctx) > 0) env->storeName("x", args->getAt(ctx, 0));
        try {
#line 9 "source.py"
#line 9 "source.py"
throw env->binaryOp(env->lookupName("x"), protoPython::TokenType::Star, ctx->fromInteger(2));
        } catch (const proto::ProtoObject* retVal) { return retVal; }
        return PROTO_NONE;
    });
    func_double = env->callObject(env->lookupName("dec"), {func_double});
    env->storeName("double", func_double);
;
#line 11 "test_decorators_final.py"
env->callObject(env->lookupName("print"), {ctx->fromUTF8String("Double(10):"), env->callObject(env->lookupName("double"), {ctx->fromInteger(10)})});
#line 13 "test_decorators_final.py"

    auto func_cls_dec = ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {
        auto* env = protoPython::PythonEnvironment::get(ctx);
        // Bind parameters
        if (args->getSize(ctx) > 0) env->storeName("c", args->getAt(ctx, 0));
        try {
#line 14 "source.py"
#line 14 "source.py"
env->callObject(env->lookupName("print"), {ctx->fromUTF8String("Decorating class")});
#line 15 "source.py"
env->setAttr(env->lookupName("c"), "flag", PROTO_TRUE);
#line 16 "source.py"
throw env->lookupName("c");
        } catch (const proto::ProtoObject* retVal) { return retVal; }
        return PROTO_NONE;
    });
    env->storeName("cls_dec", func_cls_dec);
;
#line 19 "test_decorators_final.py"

    // Class definition: A
    const proto::ProtoObject* class_name_A = ctx->fromUTF8String("A");
    std::vector<const proto::ProtoObject*> bases_A;
    auto* ns_A = const_cast<proto::ProtoObject*>(ctx->newObject(true));
    ns_A->setAttribute(ctx, env->getNameString(), class_name_A);
    {
        auto* oldFrame = protoPython::PythonEnvironment::getCurrentFrame();
        protoPython::PythonEnvironment::setCurrentFrame(ns_A);
#line 20 "source.py"

    auto func___init__ = ctx->fromMethod(nullptr, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {
        auto* env = protoPython::PythonEnvironment::get(ctx);
        // Bind parameters
        if (args->getSize(ctx) > 0) env->storeName("self", args->getAt(ctx, 0));
        if (args->getSize(ctx) > 1) env->storeName("val", args->getAt(ctx, 1));
        try {
#line 21 "source.py"
#line 21 "source.py"
env->setAttr(env->lookupName("self"), "val", env->lookupName("val"));
        } catch (const proto::ProtoObject* retVal) { return retVal; }
        return PROTO_NONE;
    });
    env->storeName("__init__", func___init__);
;
        protoPython::PythonEnvironment::setCurrentFrame(oldFrame);
    }
    auto* cls_A = const_cast<proto::ProtoObject*>(ctx->newObject(true));
    if (env->getTypePrototype()) cls_A->setAttribute(ctx, env->getClassString(), env->getTypePrototype());
    for (auto* b : bases_A) cls_A->addParent(ctx, b);
    {
        const proto::ProtoSparseList* keys = ns_A->getAttributes(ctx);
        if (keys) {
            auto it = keys->getIterator(ctx);
            while (it && it->hasNext(ctx)) {
                unsigned long key = it->nextKey(ctx);
                const proto::ProtoObject* keyObj = reinterpret_cast<const proto::ProtoObject*>(key);
                if (keyObj && keyObj->isString(ctx)) {
                    const proto::ProtoString* k = keyObj->asString(ctx);
                    cls_A->setAttribute(ctx, k, ns_A->getAttribute(ctx, k));
                }
                it = const_cast<proto::ProtoSparseListIterator*>(it)->advance(ctx);
            }
        }
    }
    cls_A->setAttribute(ctx, env->getCallString(), ctx->fromMethod(cls_A, [](proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) -> const proto::ProtoObject* {
        auto* env = protoPython::PythonEnvironment::get(ctx);
        auto* obj = const_cast<proto::ProtoObject*>(ctx->newObject(true));
        obj->addParent(ctx, self);
        const proto::ProtoObject* init = env->getAttribute(ctx, obj, env->getInitString());
        if (init && init != PROTO_NONE) {
            std::vector<const proto::ProtoObject*> vargs;
            for (unsigned long i = 0; i < args->getSize(ctx); ++i) vargs.push_back(args->getAt(ctx, i));
            env->callObject(init, vargs);
        }
        return obj;
    }));
    auto var_cls_A = static_cast<const proto::ProtoObject*>(cls_A);
    var_cls_A = env->callObject(env->lookupName("cls_dec"), {var_cls_A});
    env->storeName("A", var_cls_A);
;
#line 23 "test_decorators_final.py"
env->callObject(env->lookupName("print"), {ctx->fromUTF8String("A.flag:"), env->getAttr(env->lookupName("A"), "flag")});
#line 24 "test_decorators_final.py"
env->storeName("obj", env->callObject(env->lookupName("A"), {ctx->fromInteger(42)}));
#line 25 "test_decorators_final.py"
env->callObject(env->lookupName("print"), {ctx->fromUTF8String("obj.val:"), env->getAttr(env->lookupName("obj"), "val")});
    return nullptr;
}
