// Generated by protopyc from tests/test_generators_native.py
#include <protoCore.h>
#include <protoPython/PythonEnvironment.h>
#include <protoPython/Tokenizer.h>
#include <algorithm>


const proto::ProtoObject* py_cont_gen_1(proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) {
    auto* env = protoPython::PythonEnvironment::get(ctx);
    auto* gen = const_cast<proto::ProtoObject*>(self);
    const proto::ProtoSparseList* gi_locals = env->getAttribute(ctx, gen, env->getGiLocalsString())->asSparseList(ctx);
    int pc = env->getAttribute(ctx, gen, env->getGiPCString())->asLong(ctx);
    if (std::getenv("PROTO_ENV_DIAG")) { fprintf(stderr, "[cont] gen=%p pc=%d\n", (void*)gen, pc); fflush(stderr); }
    try {
        switch (pc) {
            case 0: 
#line 2 "source.py"
            {
                const proto::ProtoSparseList* locals = ctx->newSparseList();
                gen->setAttribute(ctx, env->getGiLocalsString(), locals->asObject(ctx));
            }
            gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(1));
            throw ctx->fromInteger(1);
        case 1:
            /* resumed from yield */
            if (std::getenv("PROTO_ENV_DIAG")) { fprintf(stderr, "[cont] resumed yield pc=1\n"); fflush(stderr); }
            ([&]() -> const proto::ProtoObject* {
                return (args && args->getSize(ctx) > 1) ? args->getAt(ctx, 1) : PROTO_NONE;
            })();
#line 3 "source.py"
            {
                const proto::ProtoSparseList* locals = ctx->newSparseList();
                gen->setAttribute(ctx, env->getGiLocalsString(), locals->asObject(ctx));
            }
            gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(2));
            throw ctx->fromInteger(2);
        case 2:
            /* resumed from yield */
            if (std::getenv("PROTO_ENV_DIAG")) { fprintf(stderr, "[cont] resumed yield pc=2\n"); fflush(stderr); }
            ([&]() -> const proto::ProtoObject* {
                return (args && args->getSize(ctx) > 1) ? args->getAt(ctx, 1) : PROTO_NONE;
            })();
#line 4 "source.py"
            {
                const proto::ProtoSparseList* locals = ctx->newSparseList();
                gen->setAttribute(ctx, env->getGiLocalsString(), locals->asObject(ctx));
            }
            gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(3));
            throw ctx->fromInteger(3);
        case 3:
            /* resumed from yield */
            if (std::getenv("PROTO_ENV_DIAG")) { fprintf(stderr, "[cont] resumed yield pc=3\n"); fflush(stderr); }
            ([&]() -> const proto::ProtoObject* {
                return (args && args->getSize(ctx) > 1) ? args->getAt(ctx, 1) : PROTO_NONE;
            })();
                break;
        }
    } catch (const proto::ProtoObject* val) {
        if (env->isStopIteration(val)) throw val;
        return val;
    }
    gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(-1));
    env->raiseStopIteration(ctx, PROTO_NONE);
    return PROTO_NONE;
}

const proto::ProtoObject* py_func_gen_1(proto::ProtoContext* ctx, const proto::ProtoObject* self, const proto::ParentLink* pl, const proto::ProtoList* args, const proto::ProtoSparseList* kwargs) {
    auto* env = protoPython::PythonEnvironment::get(ctx);
    auto* gen = const_cast<proto::ProtoObject*>(ctx->newObject(true));
    if (env->getGeneratorPrototype()) gen->addParent(ctx, env->getGeneratorPrototype());
    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiNativeCallbackString(), ctx->fromMethod(nullptr, py_cont_gen_1)));
    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiPCString(), ctx->fromInteger(0)));
    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiRunningString(), PROTO_FALSE));
    const proto::ProtoSparseList* initialLocals = ctx->newSparseList();
    unsigned long nPos = args ? args->getSize(ctx) : 0;
    gen = const_cast<proto::ProtoObject*>(gen->setAttribute(ctx, env->getGiLocalsString(), initialLocals->asObject(ctx)));
    return gen;
}
extern "C" void* proto_module_init() {
    auto* ctx = protoPython::PythonEnvironment::getCurrentContext();
    auto* env = protoPython::PythonEnvironment::get(ctx);
    if (std::getenv("PROTO_ENV_DIAG")) {
        fprintf(stderr, "[mod] proto_module_init ctx=%p\n", (void*)ctx);
        const proto::ProtoObject* p = env->lookupName("print");
        fprintf(stderr, "[mod] lookupName('print')=%p\n", (void*)p);
        fflush(stderr);
    }

#line 1 "tests/test_generators_native.py"
    const proto::ProtoObject* func_gen = ctx->fromMethod(nullptr, py_func_gen_1);
    env->storeName("gen", func_gen);
#line 6 "tests/test_generators_native.py"
env->storeName("g", env->callObject(env->lookupName("gen"), {}));
#line 7 "tests/test_generators_native.py"
env->callObject(env->lookupName("print"), {env->callObject(env->lookupName("next"), {env->lookupName("g")})});
#line 8 "tests/test_generators_native.py"
env->callObject(env->lookupName("print"), {env->callObject(env->lookupName("next"), {env->lookupName("g")})});
#line 9 "tests/test_generators_native.py"
env->callObject(env->lookupName("print"), {env->callObject(env->lookupName("next"), {env->lookupName("g")})});
#line 10 "tests/test_generators_native.py"
{
#line 11 "source.py"
env->callObject(env->lookupName("next"), {env->lookupName("g")});
        if (env->hasPendingException()) {
            auto* __exc = env->takePendingException();
            bool __handled = false;
            if (!__handled && env->isException(__exc, env->lookupName("StopIteration"))) {
                __handled = true;
#line 13 "source.py"
env->callObject(env->lookupName("print"), {ctx->fromUTF8String("Done")});
            }
            if (!__handled) env->raiseException(__exc);
        }
    };
    return nullptr;
}
